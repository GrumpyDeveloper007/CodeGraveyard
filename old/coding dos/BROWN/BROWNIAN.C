/*--------------------------------------------------------------------------*//*- PC Format Demo tutorial source #4 - By PS Jones, aka. Sandman/Valhalla -*//*--------------------------------------------------------------------------*//*- As this is likely to be the last prt of the code tutorial series, i -----*//*- thought i'd give you an insight into an effect, which few people in the -*//*- demo scene know how to do - how to create a really cool 3D coral effect -*//*---------------------------------------------------------------------------*//*- Hope you've enjoyed the series ! (Pete Jones, aka Sandman / Valhalla) ---*//*---------------------------------------------------------------------------*//* THIS IS A PORT FROM WATCOM C    compile with djgpp using :		  gcc brownian.c -o brownian.exe -O*/#include <stdio.h>#include <stdlib.h>#include <math.h>#include <dos.h>#include <conio.h>#include <string.h>#include <sys\movedata.h>#include <sys\nearptr.h>#include <pc.h>#include <go32.h>#include <dpmi.h>#define SPEEDCOMP 0.6#define CORAL_POINTS2D	8000#define CORAL_POINTS3D	8000#define GROWTH 8union REGS r;char *scrptr;/*---------------------------------------------------------------------------*/char palette[256][3], zoompic[256][256], scrbuf[200][320];long  i,j, x,y;float fx,fy;float zoomfactor=1.25;typedef struct {	long x,y,z;} point3d;					// create our own 3d point structure.point3d coral[CORAL_POINTS3D];point3d rotated[CORAL_POINTS3D];long xpos=0,ypos=0,zpos=0;		// 3d position of particlelong lastxpos,lastypos,lastzpos;long randval;char ScreenBuffer[200][320];char xbuffer[128], ybuffer[128];char texture[256][256];long growthoffset=0;unsigned char RadTable[200][320];unsigned char AngTable[200][320];float	angle1=0, angle2=0, angle3=0;float	angle1bak=0, angle2bak=0, angle3bak=0;float	angle4=0, angle5=0;float	angle4bak=0, angle5bak=0;/*--------------------------------------------------------------------------*/// Sets the graphics mode 320x200 with 256 colours //void Set320x200(void){   r.h.ah=0;   r.h.al=0x13;   int86(0x10, &r, &r);}/*--------------------------------------------------------------------------*/// Sets 80 column text mode, 25 rows //void SetTextMode(void){   r.h.ah=0;   r.h.al=0x03;   int86(0x10, &r, &r);}/*--------------------------------------------------------------------------*/// sets a pixel on the screen with the specified colour //// Most C setpixel calls are very slow, so we write our own one here. //void setpixel(long x, long y, char col){   if (x<320 && x>=0 && y>=0 && y<200)	*(scrptr + (y*320) + x) = col;}/*---------------------------------------------------------------------------*//*- Code from plasma.c and tunnel.c -----------------------------------------*//*---------------------------------------------------------------------------*/void DrawRealPlasma(void){	long i,j;	char	value;	angle1bak=angle1;	angle2bak=angle2;	angle3bak=angle3;	for (i=0; i<128; i++)	{		xbuffer[i]=8.0*sin(angle1) + 6.0*sin(angle2) + 4.0*sin(angle3);		angle1+=6.284/128;		angle2+=2*6.284/128;		angle3+=4*6.284/128;	}								angle1=angle1bak-((2*1*6.284/320)*SPEEDCOMP*4);	angle2=angle2bak+((2*3*6.284/320)*SPEEDCOMP*4);	angle3=angle3bak+((2*2*6.284/320)*SPEEDCOMP*4);	angle4bak=angle4;	angle5bak=angle5;	for (i=0; i<128; i++)	{	   		ybuffer[i]=8.0*sin(angle4) + 6.0*sin(angle5);		angle4+=6.284/128;		angle5+=2*6.284/128;	}								angle4=angle1bak+((2*3*6.284/320)*SPEEDCOMP*4);	angle5=angle2bak+((2*5*6.284/320)*SPEEDCOMP*4);			for (j=0; j<128; j++)	{		value=ybuffer[j];		for (i=0; i<128; i++)		{			texture[j][i] = (32+value+xbuffer[i]);			texture[j+128][i] = (32+value+xbuffer[i]);			texture[j][i+128] = (32+value+xbuffer[i]);			texture[j+128][i+128] = (32+value+xbuffer[i]);		}				}		}/*---------------------------------------------------------------------------*/void CalcRadiusTable_Perspect(void){	long i,j,rad;	for (j=-100; j<100; j++)	{		for (i=-160; i<160; i++)		{			rad=sqrt((i*i) + (j*j));         rad=8*32*pow((float) (256*1024*rad), 0.1);			RadTable[j+100][i+160]=rad & 255;		}			}		}	void CalcAngleTable(void){	float x,y, angle;	long i,j;	for (j=-100; j<100; j++)	{		for (i=-160; i<160; i++)		{			if(i!=0 || j!=0)			{				x=i;				y=j;				angle=atan2(y,x);				// The arc tangent function is used to 				// calculate the angle bout the centre for				// that pixel.				angle*=(256/6.284);				// scale the angle so that it is in the range                                				// 0 - 256				AngTable[j+100][i+160]=((long) angle) & 255;     			}		}			}		}	void DoTunnel(unsigned char radoff, unsigned char angoff){   long i,j;   unsigned char radius,angle;   angoff&=255;   radoff&=255;   for (j=0; j<200; j++)	{		for (i=0; i<320; i++)		{         radius=(radoff+RadTable[j][i]) & 255;         angle=radius+(angoff+AngTable[j][i]) & 255;         ScreenBuffer[j][i]=texture[radius][angle];		}			}}	/*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*/void LoadTarga(char *filename){       	FILE *in;	if ( (in=fopen(filename, "rb")) == NULL )	{		printf("Ooops cannot open %s :(\n", filename);		exit(1);                	}	fseek(in, 18, SEEK_SET);                	fread(palette, 768, 1, in);	fclose(in);}       /*---------------------------------------------------------------------------*/void SetPal(void){	short i;	disable();   outportb(0x3c8,0);	for (i=0; i<256; i++)	{      outportb(0x3c9, palette[i][2]>>2);      outportb(0x3c9, palette[i][1]>>2);      outportb(0x3c9, palette[i][0]>>2);	}	enable();}       /*---------------------------------------------------------------------------*/void SetgreyPal(void){	long i;	disable();	outportb(0x3c8,0);	for (i=0; i<255; i++)	{		outportb(0x3c9, i/4);   		outportb(0x3c9, i/4);   		outportb(0x3c9, i/4);   	}       	outportb(0x3c9, 63);   	outportb(0x3c9, 0);   	outportb(0x3c9, 0);   	enable();}       void SetgreyPal2(void){	long i;	disable();	outportb(0x3c8,0);	for (i=0; i<64; i++)	{		outportb(0x3c9, i);   		outportb(0x3c9, i);   		outportb(0x3c9, i);   	}       	enable();}       /*---------------------------------------------------------------------------*/void ShowBrownianTrail(void){	char pixel;	long i;	char *screenpointer;	#define PIXELSTOPLOT 8	for (i=0; i<PIXELSTOPLOT; i++)	{		randval=rand();			// rand returns a number between 0 and RAND_MAX		randval=randval/(RAND_MAX/4);	// we want an integer number 0-3;		if (randval==0)	xpos=xpos+1;	// move the point dependant on the random number.		else if (randval==1) xpos=xpos-1;			else if (randval==2) ypos=ypos+1;			else if (randval==3) ypos=ypos-1;			setpixel(xpos+160, ypos+100, 255);	// plot the new pixel !			}				screenpointer=(char*) scrptr;	for (i=0; i<(320*200); i++)	{		pixel=*screenpointer;		// darken each pixel on the screen		if (pixel!=0) 				// unless they are already black !		{			pixel=pixel-1;			*screenpointer=pixel;		}		screenpointer++;	}	}	/*---------------------------------------------------------------------------*/void Display2DBrownian(void){	long i;	xpos=0;	ypos=0;		for (i=0; i<CORAL_POINTS2D; i++)		{		randval=rand();			// rand returns a number between 0 and RAND_MAX		randval=randval/(RAND_MAX/4);	// we want an integer number 0-3;		if (randval==0)	xpos=xpos+1;	// move the point dependant on the random number.		else if (randval==1) xpos=xpos-1;			else if (randval==2) ypos=ypos+1;			else if (randval==3) ypos=ypos-1;			setpixel(xpos+160, ypos+100, 254);	// plot the new pixel !						setpixel(-xpos+160, -ypos+100, 254);	// plot the new pixel !					}		}	/*---------------------------------------------------------------------------*/void Create3DBrownian(void){	long i;	xpos=0;	ypos=0;	zpos=0;		for (i=0; i<CORAL_POINTS3D; i++)		{		randval=rand();			// rand returns a number between 0 and RAND_MAX		randval=randval/(RAND_MAX/6);	// we want an integer number 0-5;		if (randval==0)	xpos=xpos+1;	// move the point dependant on the random number.		else if (randval==1) xpos=xpos-1;			else if (randval==2) ypos=ypos+1;			else if (randval==3) ypos=ypos-1;			else if (randval==4) zpos=zpos+1;			else if (randval==5) zpos=zpos-1;			coral[i].x=xpos;		coral[i].y=ypos;		coral[i].z=zpos;		// store the points in an array	}			lastxpos=xpos;	lastypos=ypos;	lastzpos=zpos;}	/*---------------------------------------------------------------------------*/Display3DBrownian(void){	long i,x,y;	char pixel;	long *scrpt;	for (i=0; i<CORAL_POINTS3D; i++) 		{		x=rotated[i].x;			y=rotated[i].y;				if (abs(x)<157 && abs(y)<97) 	// screen clip		{			scrpt=(long *) &ScreenBuffer[y+99][x+159];				*scrpt+=0x00010000; scrpt+=80;			*scrpt+=0x01020100; scrpt+=80;				// plot a small transparent			*scrpt+=0x00010000; 						// sprite			scrpt=(long *) &ScreenBuffer[-y+99][-x+159];					*scrpt+=0x00010000; scrpt+=80;			*scrpt+=0x01020100; scrpt+=80;			*scrpt+=0x00010000; 		}			}				memcpy((char*) scrptr, ScreenBuffer, 64000);}	/*---------------------------------------------------------------------------*/void RotatePoints(float anglex, float angley){	long i,x,y,z;	float sinX, sinY, cosX, cosY;	float newx,newy,newz;		sinX=sin(anglex);	cosX=cos(anglex);	sinY=sin(angley);	cosY=cos(angley);			for (i=0; i<CORAL_POINTS3D; i++)	{		x=coral[i].x;			y=coral[i].y;		z=coral[i].z;				newx=x;		newy=y*cosX + z*sinX;					// rotation about X axis		newz=z*cosX - y*sinX;		rotated[i].x=newx*cosY + newz*sinY;		rotated[i].y=newy;						// rotation about Y axis		rotated[i].z=newz*cosY - newx*sinY;					}		 	}	/*---------------------------------------------------------------------------*/void FakeBlur(void){	long i,j;	char *screenpt;	unsigned char pixel;	screenpt=(char*) ScreenBuffer;		for (j=0; j<200; j++)	{		for(i=0; i<320; i++)		{										// darken the entire screen			pixel=*screenpt;			if (pixel>63) *screenpt=63;			//make sure we don't get any							else if (pixel>1) *screenpt-=2;		//overflows	next frame			else *screenpt=0;			screenpt++;		}		}		}	/*---------------------------------------------------------------------------*/void BrownianGrowth(void){	long i,j;	xpos=lastxpos;	ypos=lastypos;	zpos=lastzpos;	j=growthoffset;			for (i=0; i<GROWTH; i++)		{		randval=rand();			// rand returns a number between 0 and RAND_MAX		randval=randval/(RAND_MAX/6);	// we want an integer number 0-5;		if (randval==0)	xpos=xpos+1;	// move the point dependant on the random number.		else if (randval==1) xpos=xpos-1;			else if (randval==2) ypos=ypos+1;			else if (randval==3) ypos=ypos-1;			else if (randval==4) zpos=zpos+1;			else if (randval==5) zpos=zpos-1;			coral[j].x=xpos;		coral[j].y=ypos;		coral[j].z=zpos;		// store the points in an array		j++;		if (j>CORAL_POINTS3D) j=0;	}			growthoffset=j;	lastxpos=xpos;	lastypos=ypos;	lastzpos=zpos;}	/*---------------------------------------------------------------------------*/int main(void){   float rotate_angle=0;   long fc;   	__djgpp_nearptr_enable();	scrptr = (char*) (__djgpp_conventional_base + 0xa0000);	   	LoadTarga("pal1.tga");	Set320x200();		SetgreyPal();	while (!kbhit())   	{   		ShowBrownianTrail();   	}   	getch();		memset((char*) scrptr, 0, 64000);	 	Display2DBrownian();		   	getch();	Create3DBrownian();		SetPal();	while (!kbhit()) 	{		rotate_angle+=6.284/512;		RotatePoints(rotate_angle, rotate_angle*2.72);	 	Display3DBrownian();								memset(ScreenBuffer, 0, 64000);	}   	getch();	while (!kbhit()) 	{		rotate_angle+=6.284/512;		RotatePoints(rotate_angle, rotate_angle*2.72);	 	Display3DBrownian();			 	BrownianGrowth();						memset(ScreenBuffer, 0, 64000);	}   	getch();	while (!kbhit()) 	{		rotate_angle+=6.284/1024;		RotatePoints(rotate_angle, rotate_angle*2.72);	 	Display3DBrownian();								FakeBlur();	}   	getch();	fc=0;	CalcRadiusTable_Perspect();	CalcAngleTable();		LoadTarga("pal2.tga");	SetPal();	while (!kbhit()) 	{		rotate_angle+=6.284/512;		RotatePoints(rotate_angle, rotate_angle*2.72);		DrawRealPlasma();		DoTunnel(-fc*4, fc/2);	 	Display3DBrownian();	 	fc++;							}   	getch();	SetTextMode();	return(0);}       /*---------------------------------------------------------------------------*/